import { z } from "zod/v4";
import { BaseRow } from ".";
import { Runner } from "../runner/Runner";
import assert from "assert";
import { Row } from "../information/Table";

/** ------------------------------------------------------------------------- */

export interface UtilityRowData {
  type: "utility";
  table: string;
  match: string;
  take: string;
  group: string;
}

/** ------------------------------------------------------------------------- */

/**
 * A `<reference>` tag, but for utilities.
 * 
 * Utilities are dynamically generated by other transformers.
 * 
 * @see ReferenceRow
 */
export class UtilityRow implements BaseRow {
  private readonly table: string;
  private readonly match: string;
  private readonly take: string;
  private readonly group: string;

  public constructor(table: string, match: string, take: string, group: string) {
    this.table = table;
    this.match = match;
    this.take = take;
    this.group = group;
  }

  run(value: string, _r: Row, runner: Runner): Maybe<string> {
    const utility = runner.utilities.get(this.table);
    const view = utility.view(this.match);

    const result = view.ask({
      [this.match]: value,
      group: this.group,
    }, this.take);
    
    assert.ok(result != null, `Table '${this.table}' has no '${this.match}' for '${value}'.`);
    
    return result;
  }

  buildJSON(): UtilityRowData {
    return { type: "utility", table: this.table, match: this.match, take: this.take, group: this.group };
  }

  public static readonly SCHEMA: z.ZodType<BaseRow, UtilityRowData> = z.strictObject({
    type: z.literal("utility"),
    table: z.string(),
    match: z.string(),
    take: z.string(),
    group: z.string(),
  }).transform(s => new UtilityRow(s.table, s.match, s.take, s.group));
}
